"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Vertex = void 0;
/**
 * @packageDocumentation
 * @module API-AVM-Vertex
 */
const buffer_1 = require("buffer/");
const bintools_1 = __importDefault(require("../../utils/bintools"));
const constants_1 = require("./constants");
const outputs_1 = require("./outputs");
const inputs_1 = require("./inputs");
const constants_2 = require("../../utils/constants");
const tx_1 = require("./tx");
const serialization_1 = require("../../utils/serialization");
const errors_1 = require("../../utils/errors");
/**
 * @ignore
 */
const bintools = bintools_1.default.getInstance();
const serialization = serialization_1.Serialization.getInstance();
const decimalString = "decimalString";
const buffer = "Buffer";
const display = "display";
/**
 * Class representing a Vertex
 */
class Vertex extends serialization_1.Serializable {
    /**
     * Takes the bytes of an [[UnsignedTx]] and returns an array of [[Credential]]s
     *
     * @param msg A Buffer for the [[UnsignedTx]]
     * @param kc An [[KeyChain]] used in signing
     *
     * @returns An array of [[Credential]]s
     */
    // sign(msg: Buffer, kc: KeyChain): Credential[] {
    //   const sigs: Credential[] = []
    //   for (let i: number = 0; i < this.ins.length; i++) {
    //     const cred: Credential = SelectCredentialClass(
    //       this.ins[`${i}`].getInput().getCredentialID()
    //     )
    //     const sigidxs: SigIdx[] = this.ins[`${i}`].getInput().getSigIdxs()
    //     for (let j: number = 0; j < sigidxs.length; j++) {
    //       const keypair: KeyPair = kc.getKey(sigidxs[`${j}`].getSource())
    //       const signval: Buffer = keypair.sign(msg)
    //       const sig: Signature = new Signature()
    //       sig.fromBuffer(signval)
    //       cred.addSignature(sig)
    //     }
    //     sigs.push(cred)
    //   }
    //   return sigs
    // }
    // clone(): this {
    //   let newbase: BaseTx = new BaseTx()
    //   newbase.fromBuffer(this.toBuffer())
    //   return newbase as this
    // }
    // create(...args: any[]): this {
    //   return new BaseTx(...args) as this
    // }
    // select(id: number, ...args: any[]): this {
    //   let newbasetx: BaseTx = SelectTxClass(id, ...args)
    //   return newbasetx as this
    // }
    /**
     * Class representing a BaseTx which is the foundation for all transactions.
     *
     * @param networkID Optional networkID, [[DefaultNetworkID]]
     * @param chainID Optional chainID, default Buffer.alloc(32, 16)
     */
    constructor(networkID = constants_2.DefaultNetworkID, chainID = buffer_1.Buffer.alloc(32), height = buffer_1.Buffer.alloc(8), epoch = buffer_1.Buffer.alloc(4), parentIDs = [], txs = buffer_1.Buffer.alloc(4), numRestrictions = buffer_1.Buffer.alloc(4), restrictions = []) {
        super();
        this._typeName = "Vertex";
        this._codecID = constants_1.AVMConstants.LATESTCODEC;
        this.out = new outputs_1.TransferableOutput();
        this.ins = new inputs_1.TransferableInput();
        this.numouts = new outputs_1.TransferableOutput();
        this.numins = new inputs_1.TransferableInput();
        this.chainID = buffer_1.Buffer.alloc(32);
        this.height = buffer_1.Buffer.alloc(8);
        this.epoch = buffer_1.Buffer.alloc(4);
        this.numParentIDs = buffer_1.Buffer.alloc(4);
        this.parentIDs = [];
        this.numTxs = buffer_1.Buffer.alloc(4);
        this.txs = [];
        this.numRestrictions = buffer_1.Buffer.alloc(4);
        this.restrictions = [];
        /**
         * Returns the ChainID as a number
         */
        this.getChainID = () => this.chainID.readUInt32BE(0);
        /**
         * Returns the height as a {@link https://github.com/indutny/bn.js/|BN}.
         */
        this.getHeight = () => bintools.fromBufferToBN(this.height);
        /**
         * Returns the epoch as a number.
         */
        this.getEpoch = () => this.epoch.readUInt32BE(0);
        /**
         * @returns An array of Buffers
         */
        this.getParentIDs = () => {
            return this.parentIDs;
        };
        /**
         * Returns array of UnsignedTxs.
         */
        this.getTxs = () => {
            return this.txs;
        };
        /**
         * @returns An array of Buffers
         */
        this.getRestrictions = () => {
            return this.restrictions;
        };
    }
    // serialize is inherited
    // TODO - implement deserialize
    deserialize(fields, encoding = "hex") {
        super.deserialize(fields, encoding);
        this.out = fields["outs"].map((o) => {
            let newOut = new outputs_1.TransferableOutput();
            newOut.deserialize(o, encoding);
            return newOut;
        });
        this.ins = fields["ins"].map((i) => {
            let newIn = new inputs_1.TransferableInput();
            newIn.deserialize(i, encoding);
            return newIn;
        });
        // this.numouts = serialization.decoder(
        //   this.out.length.toString(),
        //   display,
        //   decimalString,
        //   buffer,
        //   4
        // )
        // this.numins = serialization.decoder(
        //   this.ins.length.toString(),
        //   display,
        //   decimalString,
        //   buffer,
        //   4
        // )
    }
    /**
     * Set the codecID
     *
     * @param codecID The codecID to set
     */
    setCodecID(codecID) {
        if (codecID !== 0 && codecID !== 1) {
            /* istanbul ignore next */
            throw new errors_1.CodecIdError("Error - BaseTx.setCodecID: invalid codecID. Valid codecIDs are 0 and 1.");
        }
        this._codecID = codecID;
        this._typeID =
            this._codecID === 0 ? constants_1.AVMConstants.BASETX : constants_1.AVMConstants.BASETX_CODECONE;
    }
    /**
     * Takes a {@link https://github.com/feross/buffer|Buffer} containing an [[BaseTx]], parses it, populates the class, and returns the length of the BaseTx in bytes.
     *
     * @param bytes A {@link https://github.com/feross/buffer|Buffer} containing a raw [[BaseTx]]
     *
     * @returns The length of the raw [[BaseTx]]
     *
     * @remarks assume not-checksummed
     */
    fromBuffer(bytes, offset = 0) {
        offset += 2;
        this.chainID = bintools.copyFrom(bytes, offset, offset + 32);
        offset += 32;
        this.height = bintools.copyFrom(bytes, offset, offset + 8);
        offset += 8;
        this.epoch = bintools.copyFrom(bytes, offset, offset + 4);
        offset += 4;
        this.numParentIDs = bintools.copyFrom(bytes, offset, offset + 4);
        offset += 4;
        const parentIDsCount = this.numParentIDs.readUInt32BE(0);
        for (let i = 0; i < parentIDsCount; i++) {
            const parentID = bintools.copyFrom(bytes, offset, offset + 32);
            offset += 32;
            this.parentIDs.push(parentID);
        }
        this.numTxs = bintools.copyFrom(bytes, offset, offset + 4);
        const txsCount = this.numTxs.readUInt32BE(0);
        offset += 4;
        // TODO - why do we have these 4 mystery bytes?
        offset += 4;
        for (let i = 0; i < txsCount; i++) {
            const unsignedTx = new tx_1.UnsignedTx();
            offset += unsignedTx.fromBuffer(bintools.copyFrom(bytes, offset));
            this.txs.push(unsignedTx.getTransaction());
        }
        this.numRestrictions = bintools.copyFrom(bytes, offset, offset + 4);
        offset += 4;
        const restrictionsCount = this.numRestrictions.readUInt32BE(0);
        for (let i = 0; i < restrictionsCount; i++) {
            const tx = bintools.copyFrom(bytes, offset, offset + 32);
            offset += 32;
            this.restrictions.push(tx);
        }
        return offset;
    }
}
exports.Vertex = Vertex;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVydGV4LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2FwaXMvYXZtL3ZlcnRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7O0dBR0c7QUFDSCxvQ0FBZ0M7QUFDaEMsb0VBQTJDO0FBQzNDLDJDQUEwQztBQUMxQyx1Q0FBOEM7QUFDOUMscUNBQTRDO0FBSTVDLHFEQUF3RDtBQUN4RCw2QkFBZ0Q7QUFDaEQsNkRBS2tDO0FBQ2xDLCtDQUFpRDtBQU1qRDs7R0FFRztBQUNILE1BQU0sUUFBUSxHQUFhLGtCQUFRLENBQUMsV0FBVyxFQUFFLENBQUE7QUFDakQsTUFBTSxhQUFhLEdBQWtCLDZCQUFhLENBQUMsV0FBVyxFQUFFLENBQUE7QUFDaEUsTUFBTSxhQUFhLEdBQW1CLGVBQWUsQ0FBQTtBQUNyRCxNQUFNLE1BQU0sR0FBbUIsUUFBUSxDQUFBO0FBQ3ZDLE1BQU0sT0FBTyxHQUF1QixTQUFTLENBQUE7QUFFN0M7O0dBRUc7QUFDSCxNQUFhLE1BQU8sU0FBUSw0QkFBWTtJQXFKdEM7Ozs7Ozs7T0FPRztJQUNILGtEQUFrRDtJQUNsRCxrQ0FBa0M7SUFDbEMsd0RBQXdEO0lBQ3hELHNEQUFzRDtJQUN0RCxzREFBc0Q7SUFDdEQsUUFBUTtJQUNSLHlFQUF5RTtJQUN6RSx5REFBeUQ7SUFDekQsd0VBQXdFO0lBQ3hFLGtEQUFrRDtJQUNsRCwrQ0FBK0M7SUFDL0MsZ0NBQWdDO0lBQ2hDLCtCQUErQjtJQUMvQixRQUFRO0lBQ1Isc0JBQXNCO0lBQ3RCLE1BQU07SUFDTixnQkFBZ0I7SUFDaEIsSUFBSTtJQUVKLGtCQUFrQjtJQUNsQix1Q0FBdUM7SUFDdkMsd0NBQXdDO0lBQ3hDLDJCQUEyQjtJQUMzQixJQUFJO0lBRUosaUNBQWlDO0lBQ2pDLHVDQUF1QztJQUN2QyxJQUFJO0lBRUosNkNBQTZDO0lBQzdDLHVEQUF1RDtJQUN2RCw2QkFBNkI7SUFDN0IsSUFBSTtJQUVKOzs7OztPQUtHO0lBQ0gs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ZSxJQUFJLGVBQVUsRUFBRSxDQUFBO1lBQy9DLE1BQU0sSUFBSSxVQUFVLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUE7WUFDakUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUE7U0FDM0M7UUFFRCxJQUFJLENBQUMsZUFBZSxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUE7UUFDbkUsTUFBTSxJQUFJLENBQUMsQ0FBQTtRQUNYLE1BQU0saUJBQWlCLEdBQVcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUE7UUFDdEUsS0FBSyxJQUFJLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGlCQUFpQixFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ2xELE1BQU0sRUFBRSxHQUFXLFFBQVEsQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLEdBQUcsRUFBRSxDQUFDLENBQUE7WUFDaEUsTUFBTSxJQUFJLEVBQUUsQ0FBQTtZQUNaLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFBO1NBQzNCO1FBQ0QsT0FBTyxNQUFNLENBQUE7SUFDZixDQUFDO0NBOERGO0FBak5ELHdCQWlOQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIEFQSS1BVk0tVmVydGV4XG4gKi9cbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gXCJidWZmZXIvXCJcbmltcG9ydCBCaW5Ub29scyBmcm9tIFwiLi4vLi4vdXRpbHMvYmludG9vbHNcIlxuaW1wb3J0IHsgQVZNQ29uc3RhbnRzIH0gZnJvbSBcIi4vY29uc3RhbnRzXCJcbmltcG9ydCB7IFRyYW5zZmVyYWJsZU91dHB1dCB9IGZyb20gXCIuL291dHB1dHNcIlxuaW1wb3J0IHsgVHJhbnNmZXJhYmxlSW5wdXQgfSBmcm9tIFwiLi9pbnB1dHNcIlxuaW1wb3J0IHsgU2VsZWN0Q3JlZGVudGlhbENsYXNzIH0gZnJvbSBcIi4vY3JlZGVudGlhbHNcIlxuaW1wb3J0IHsgS2V5Q2hhaW4sIEtleVBhaXIgfSBmcm9tIFwiLi9rZXljaGFpblwiXG5pbXBvcnQgeyBTaWduYXR1cmUsIFNpZ0lkeCwgQ3JlZGVudGlhbCB9IGZyb20gXCIuLi8uLi9jb21tb24vY3JlZGVudGlhbHNcIlxuaW1wb3J0IHsgRGVmYXVsdE5ldHdvcmtJRCB9IGZyb20gXCIuLi8uLi91dGlscy9jb25zdGFudHNcIlxuaW1wb3J0IHsgU2VsZWN0VHhDbGFzcywgVW5zaWduZWRUeCB9IGZyb20gXCIuL3R4XCJcbmltcG9ydCB7XG4gIFNlcmlhbGl6YWJsZSxcbiAgU2VyaWFsaXphdGlvbixcbiAgU2VyaWFsaXplZEVuY29kaW5nLFxuICBTZXJpYWxpemVkVHlwZVxufSBmcm9tIFwiLi4vLi4vdXRpbHMvc2VyaWFsaXphdGlvblwiXG5pbXBvcnQgeyBDb2RlY0lkRXJyb3IgfSBmcm9tIFwiLi4vLi4vdXRpbHMvZXJyb3JzXCJcbmltcG9ydCB7IEFkZHJlc3MgfSBmcm9tIFwiLi4vLi4vY29tbW9uXCJcbmltcG9ydCBCTiBmcm9tIFwiYm4uanNcIlxuaW1wb3J0IHsgQmFzZVR4IH0gZnJvbSBcIi5cIlxuaW1wb3J0IHsgT3V0cHV0LCBPdXRwdXRPd25lcnMgfSBmcm9tIFwiLi4vLi4vY29tbW9uL291dHB1dFwiXG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5jb25zdCBiaW50b29sczogQmluVG9vbHMgPSBCaW5Ub29scy5nZXRJbnN0YW5jZSgpXG5jb25zdCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gU2VyaWFsaXphdGlvbi5nZXRJbnN0YW5jZSgpXG5jb25zdCBkZWNpbWFsU3RyaW5nOiBTZXJpYWxpemVkVHlwZSA9IFwiZGVjaW1hbFN0cmluZ1wiXG5jb25zdCBidWZmZXI6IFNlcmlhbGl6ZWRUeXBlID0gXCJCdWZmZXJcIlxuY29uc3QgZGlzcGxheTogU2VyaWFsaXplZEVuY29kaW5nID0gXCJkaXNwbGF5XCJcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBWZXJ0ZXhcbiAqL1xuZXhwb3J0IGNsYXNzIFZlcnRleCBleHRlbmRzIFNlcmlhbGl6YWJsZSB7XG4gIHByb3RlY3RlZCBfdHlwZU5hbWUgPSBcIlZlcnRleFwiXG4gIHByb3RlY3RlZCBfY29kZWNJRCA9IEFWTUNvbnN0YW50cy5MQVRFU1RDT0RFQ1xuICBwcm90ZWN0ZWQgb3V0OiBUcmFuc2ZlcmFibGVPdXRwdXQgPSBuZXcgVHJhbnNmZXJhYmxlT3V0cHV0KClcbiAgcHJvdGVjdGVkIGluczogVHJhbnNmZXJhYmxlSW5wdXQgPSBuZXcgVHJhbnNmZXJhYmxlSW5wdXQoKVxuICBwcm90ZWN0ZWQgbnVtb3V0czogVHJhbnNmZXJhYmxlT3V0cHV0ID0gbmV3IFRyYW5zZmVyYWJsZU91dHB1dCgpXG4gIHByb3RlY3RlZCBudW1pbnM6IFRyYW5zZmVyYWJsZUlucHV0ID0gbmV3IFRyYW5zZmVyYWJsZUlucHV0KClcblxuICAvLyBzZXJpYWxpemUgaXMgaW5oZXJpdGVkXG5cbiAgLy8gVE9ETyAtIGltcGxlbWVudCBkZXNlcmlhbGl6ZVxuICBkZXNlcmlhbGl6ZShmaWVsZHM6IG9iamVjdCwgZW5jb2Rpbmc6IFNlcmlhbGl6ZWRFbmNvZGluZyA9IFwiaGV4XCIpIHtcbiAgICBzdXBlci5kZXNlcmlhbGl6ZShmaWVsZHMsIGVuY29kaW5nKVxuICAgIHRoaXMub3V0ID0gZmllbGRzW1wib3V0c1wiXS5tYXAoKG86IFRyYW5zZmVyYWJsZU91dHB1dCkgPT4ge1xuICAgICAgbGV0IG5ld091dDogVHJhbnNmZXJhYmxlT3V0cHV0ID0gbmV3IFRyYW5zZmVyYWJsZU91dHB1dCgpXG4gICAgICBuZXdPdXQuZGVzZXJpYWxpemUobywgZW5jb2RpbmcpXG4gICAgICByZXR1cm4gbmV3T3V0XG4gICAgfSlcbiAgICB0aGlzLmlucyA9IGZpZWxkc1tcImluc1wiXS5tYXAoKGk6IFRyYW5zZmVyYWJsZUlucHV0KSA9PiB7XG4gICAgICBsZXQgbmV3SW46IFRyYW5zZmVyYWJsZUlucHV0ID0gbmV3IFRyYW5zZmVyYWJsZUlucHV0KClcbiAgICAgIG5ld0luLmRlc2VyaWFsaXplKGksIGVuY29kaW5nKVxuICAgICAgcmV0dXJuIG5ld0luXG4gICAgfSlcbiAgICAvLyB0aGlzLm51bW91dHMgPSBzZXJpYWxpemF0aW9uLmRlY29kZXIoXG4gICAgLy8gICB0aGlzLm91dC5sZW5ndGgudG9TdHJpbmcoKSxcbiAgICAvLyAgIGRpc3BsYXksXG4gICAgLy8gICBkZWNpbWFsU3RyaW5nLFxuICAgIC8vICAgYnVmZmVyLFxuICAgIC8vICAgNFxuICAgIC8vIClcbiAgICAvLyB0aGlzLm51bWlucyA9IHNlcmlhbGl6YXRpb24uZGVjb2RlcihcbiAgICAvLyAgIHRoaXMuaW5zLmxlbmd0aC50b1N0cmluZygpLFxuICAgIC8vICAgZGlzcGxheSxcbiAgICAvLyAgIGRlY2ltYWxTdHJpbmcsXG4gICAgLy8gICBidWZmZXIsXG4gICAgLy8gICA0XG4gICAgLy8gKVxuICB9XG4gIHByb3RlY3RlZCBjaGFpbklEOiBCdWZmZXIgPSBCdWZmZXIuYWxsb2MoMzIpXG4gIHByb3RlY3RlZCBoZWlnaHQ6IEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg4KVxuICBwcm90ZWN0ZWQgZXBvY2g6IEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KVxuICBwcm90ZWN0ZWQgbnVtUGFyZW50SURzOiBCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNClcbiAgcHJvdGVjdGVkIHBhcmVudElEczogQnVmZmVyW10gPSBbXVxuICBwcm90ZWN0ZWQgbnVtVHhzOiBCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNClcbiAgcHJvdGVjdGVkIHR4czogQmFzZVR4W10gPSBbXVxuICBwcm90ZWN0ZWQgbnVtUmVzdHJpY3Rpb25zOiBCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNClcbiAgcHJvdGVjdGVkIHJlc3RyaWN0aW9uczogQnVmZmVyW10gPSBbXVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBDaGFpbklEIGFzIGEgbnVtYmVyXG4gICAqL1xuICBnZXRDaGFpbklEID0gKCk6IG51bWJlciA9PiB0aGlzLmNoYWluSUQucmVhZFVJbnQzMkJFKDApXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlaWdodCBhcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59LlxuICAgKi9cbiAgZ2V0SGVpZ2h0ID0gKCk6IEJOID0+IGJpbnRvb2xzLmZyb21CdWZmZXJUb0JOKHRoaXMuaGVpZ2h0KVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBhcyBhIG51bWJlci5cbiAgICovXG4gIGdldEVwb2NoID0gKCk6IG51bWJlciA9PiB0aGlzLmVwb2NoLnJlYWRVSW50MzJCRSgwKVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBCdWZmZXJzXG4gICAqL1xuICBnZXRQYXJlbnRJRHMgPSAoKTogQnVmZmVyW10gPT4ge1xuICAgIHJldHVybiB0aGlzLnBhcmVudElEc1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYXJyYXkgb2YgVW5zaWduZWRUeHMuXG4gICAqL1xuICBnZXRUeHMgPSAoKTogQmFzZVR4W10gPT4ge1xuICAgIHJldHVybiB0aGlzLnR4c1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIEJ1ZmZlcnNcbiAgICovXG4gIGdldFJlc3RyaWN0aW9ucyA9ICgpOiBCdWZmZXJbXSA9PiB7XG4gICAgcmV0dXJuIHRoaXMucmVzdHJpY3Rpb25zXG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjb2RlY0lEXG4gICAqXG4gICAqIEBwYXJhbSBjb2RlY0lEIFRoZSBjb2RlY0lEIHRvIHNldFxuICAgKi9cbiAgc2V0Q29kZWNJRChjb2RlY0lEOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoY29kZWNJRCAhPT0gMCAmJiBjb2RlY0lEICE9PSAxKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhyb3cgbmV3IENvZGVjSWRFcnJvcihcbiAgICAgICAgXCJFcnJvciAtIEJhc2VUeC5zZXRDb2RlY0lEOiBpbnZhbGlkIGNvZGVjSUQuIFZhbGlkIGNvZGVjSURzIGFyZSAwIGFuZCAxLlwiXG4gICAgICApXG4gICAgfVxuICAgIHRoaXMuX2NvZGVjSUQgPSBjb2RlY0lEXG4gICAgdGhpcy5fdHlwZUlEID1cbiAgICAgIHRoaXMuX2NvZGVjSUQgPT09IDAgPyBBVk1Db25zdGFudHMuQkFTRVRYIDogQVZNQ29uc3RhbnRzLkJBU0VUWF9DT0RFQ09ORVxuICB9XG5cbiAgLyoqXG4gICAqIFRha2VzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gY29udGFpbmluZyBhbiBbW0Jhc2VUeF1dLCBwYXJzZXMgaXQsIHBvcHVsYXRlcyB0aGUgY2xhc3MsIGFuZCByZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIEJhc2VUeCBpbiBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIGJ5dGVzIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gY29udGFpbmluZyBhIHJhdyBbW0Jhc2VUeF1dXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBsZW5ndGggb2YgdGhlIHJhdyBbW0Jhc2VUeF1dXG4gICAqXG4gICAqIEByZW1hcmtzIGFzc3VtZSBub3QtY2hlY2tzdW1tZWRcbiAgICovXG4gIGZyb21CdWZmZXIoYnl0ZXM6IEJ1ZmZlciwgb2Zmc2V0OiBudW1iZXIgPSAwKTogbnVtYmVyIHtcbiAgICBvZmZzZXQgKz0gMlxuICAgIHRoaXMuY2hhaW5JRCA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDMyKVxuICAgIG9mZnNldCArPSAzMlxuICAgIHRoaXMuaGVpZ2h0ID0gYmludG9vbHMuY29weUZyb20oYnl0ZXMsIG9mZnNldCwgb2Zmc2V0ICsgOClcbiAgICBvZmZzZXQgKz0gOFxuICAgIHRoaXMuZXBvY2ggPSBiaW50b29scy5jb3B5RnJvbShieXRlcywgb2Zmc2V0LCBvZmZzZXQgKyA0KVxuICAgIG9mZnNldCArPSA0XG4gICAgdGhpcy5udW1QYXJlbnRJRHMgPSBiaW50b29scy5jb3B5RnJvbShieXRlcywgb2Zmc2V0LCBvZmZzZXQgKyA0KVxuICAgIG9mZnNldCArPSA0XG4gICAgY29uc3QgcGFyZW50SURzQ291bnQ6IG51bWJlciA9IHRoaXMubnVtUGFyZW50SURzLnJlYWRVSW50MzJCRSgwKVxuICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBwYXJlbnRJRHNDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJlbnRJRDogQnVmZmVyID0gYmludG9vbHMuY29weUZyb20oYnl0ZXMsIG9mZnNldCwgb2Zmc2V0ICsgMzIpXG4gICAgICBvZmZzZXQgKz0gMzJcbiAgICAgIHRoaXMucGFyZW50SURzLnB1c2gocGFyZW50SUQpXG4gICAgfVxuXG4gICAgdGhpcy5udW1UeHMgPSBiaW50b29scy5jb3B5RnJvbShieXRlcywgb2Zmc2V0LCBvZmZzZXQgKyA0KVxuICAgIGNvbnN0IHR4c0NvdW50OiBudW1iZXIgPSB0aGlzLm51bVR4cy5yZWFkVUludDMyQkUoMClcbiAgICBvZmZzZXQgKz0gNFxuICAgIC8vIFRPRE8gLSB3aHkgZG8gd2UgaGF2ZSB0aGVzZSA0IG15c3RlcnkgYnl0ZXM/XG4gICAgb2Zmc2V0ICs9IDRcbiAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdHhzQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgdW5zaWduZWRUeDogVW5zaWduZWRUeCA9IG5ldyBVbnNpZ25lZFR4KClcbiAgICAgIG9mZnNldCArPSB1bnNpZ25lZFR4LmZyb21CdWZmZXIoYmludG9vbHMuY29weUZyb20oYnl0ZXMsIG9mZnNldCkpXG4gICAgICB0aGlzLnR4cy5wdXNoKHVuc2lnbmVkVHguZ2V0VHJhbnNhY3Rpb24oKSlcbiAgICB9XG5cbiAgICB0aGlzLm51bVJlc3RyaWN0aW9ucyA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDQpXG4gICAgb2Zmc2V0ICs9IDRcbiAgICBjb25zdCByZXN0cmljdGlvbnNDb3VudDogbnVtYmVyID0gdGhpcy5udW1SZXN0cmljdGlvbnMucmVhZFVJbnQzMkJFKDApXG4gICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHJlc3RyaWN0aW9uc0NvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHR4OiBCdWZmZXIgPSBiaW50b29scy5jb3B5RnJvbShieXRlcywgb2Zmc2V0LCBvZmZzZXQgKyAzMilcbiAgICAgIG9mZnNldCArPSAzMlxuICAgICAgdGhpcy5yZXN0cmljdGlvbnMucHVzaCh0eClcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldFxuICB9XG5cbiAgLyoqXG4gICAqIFRha2VzIHRoZSBieXRlcyBvZiBhbiBbW1Vuc2lnbmVkVHhdXSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBbW0NyZWRlbnRpYWxdXXNcbiAgICpcbiAgICogQHBhcmFtIG1zZyBBIEJ1ZmZlciBmb3IgdGhlIFtbVW5zaWduZWRUeF1dXG4gICAqIEBwYXJhbSBrYyBBbiBbW0tleUNoYWluXV0gdXNlZCBpbiBzaWduaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIFtbQ3JlZGVudGlhbF1dc1xuICAgKi9cbiAgLy8gc2lnbihtc2c6IEJ1ZmZlciwga2M6IEtleUNoYWluKTogQ3JlZGVudGlhbFtdIHtcbiAgLy8gICBjb25zdCBzaWdzOiBDcmVkZW50aWFsW10gPSBbXVxuICAvLyAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLmlucy5sZW5ndGg7IGkrKykge1xuICAvLyAgICAgY29uc3QgY3JlZDogQ3JlZGVudGlhbCA9IFNlbGVjdENyZWRlbnRpYWxDbGFzcyhcbiAgLy8gICAgICAgdGhpcy5pbnNbYCR7aX1gXS5nZXRJbnB1dCgpLmdldENyZWRlbnRpYWxJRCgpXG4gIC8vICAgICApXG4gIC8vICAgICBjb25zdCBzaWdpZHhzOiBTaWdJZHhbXSA9IHRoaXMuaW5zW2Ake2l9YF0uZ2V0SW5wdXQoKS5nZXRTaWdJZHhzKClcbiAgLy8gICAgIGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCBzaWdpZHhzLmxlbmd0aDsgaisrKSB7XG4gIC8vICAgICAgIGNvbnN0IGtleXBhaXI6IEtleVBhaXIgPSBrYy5nZXRLZXkoc2lnaWR4c1tgJHtqfWBdLmdldFNvdXJjZSgpKVxuICAvLyAgICAgICBjb25zdCBzaWdudmFsOiBCdWZmZXIgPSBrZXlwYWlyLnNpZ24obXNnKVxuICAvLyAgICAgICBjb25zdCBzaWc6IFNpZ25hdHVyZSA9IG5ldyBTaWduYXR1cmUoKVxuICAvLyAgICAgICBzaWcuZnJvbUJ1ZmZlcihzaWdudmFsKVxuICAvLyAgICAgICBjcmVkLmFkZFNpZ25hdHVyZShzaWcpXG4gIC8vICAgICB9XG4gIC8vICAgICBzaWdzLnB1c2goY3JlZClcbiAgLy8gICB9XG4gIC8vICAgcmV0dXJuIHNpZ3NcbiAgLy8gfVxuXG4gIC8vIGNsb25lKCk6IHRoaXMge1xuICAvLyAgIGxldCBuZXdiYXNlOiBCYXNlVHggPSBuZXcgQmFzZVR4KClcbiAgLy8gICBuZXdiYXNlLmZyb21CdWZmZXIodGhpcy50b0J1ZmZlcigpKVxuICAvLyAgIHJldHVybiBuZXdiYXNlIGFzIHRoaXNcbiAgLy8gfVxuXG4gIC8vIGNyZWF0ZSguLi5hcmdzOiBhbnlbXSk6IHRoaXMge1xuICAvLyAgIHJldHVybiBuZXcgQmFzZVR4KC4uLmFyZ3MpIGFzIHRoaXNcbiAgLy8gfVxuXG4gIC8vIHNlbGVjdChpZDogbnVtYmVyLCAuLi5hcmdzOiBhbnlbXSk6IHRoaXMge1xuICAvLyAgIGxldCBuZXdiYXNldHg6IEJhc2VUeCA9IFNlbGVjdFR4Q2xhc3MoaWQsIC4uLmFyZ3MpXG4gIC8vICAgcmV0dXJuIG5ld2Jhc2V0eCBhcyB0aGlzXG4gIC8vIH1cblxuICAvKipcbiAgICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgQmFzZVR4IHdoaWNoIGlzIHRoZSBmb3VuZGF0aW9uIGZvciBhbGwgdHJhbnNhY3Rpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gbmV0d29ya0lEIE9wdGlvbmFsIG5ldHdvcmtJRCwgW1tEZWZhdWx0TmV0d29ya0lEXV1cbiAgICogQHBhcmFtIGNoYWluSUQgT3B0aW9uYWwgY2hhaW5JRCwgZGVmYXVsdCBCdWZmZXIuYWxsb2MoMzIsIDE2KVxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgbmV0d29ya0lEOiBudW1iZXIgPSBEZWZhdWx0TmV0d29ya0lELFxuICAgIGNoYWluSUQ6IEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygzMiksXG4gICAgaGVpZ2h0OiBCdWZmZXIgPSBCdWZmZXIuYWxsb2MoOCksXG4gICAgZXBvY2g6IEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KSxcbiAgICBwYXJlbnRJRHM6IEFkZHJlc3NbXSA9IFtdLFxuICAgIHR4czogQnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpLFxuICAgIG51bVJlc3RyaWN0aW9uczogQnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpLFxuICAgIHJlc3RyaWN0aW9uczogQWRkcmVzc1tdID0gW11cbiAgKSB7XG4gICAgc3VwZXIoKVxuICB9XG59XG4iXX0=