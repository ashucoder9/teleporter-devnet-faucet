[{"/Users/ashutosh/Desktop/avalanche-faucet/client/src/index.tsx":"1","/Users/ashutosh/Desktop/avalanche-faucet/client/src/App.tsx":"2","/Users/ashutosh/Desktop/avalanche-faucet/client/src/configure.ts":"3","/Users/ashutosh/Desktop/avalanche-faucet/client/src/components/FaucetForm.tsx":"4","/Users/ashutosh/Desktop/avalanche-faucet/client/src/components/Contribute.tsx":"5","/Users/ashutosh/Desktop/avalanche-faucet/client/src/components/ReCaptcha.ts":"6","/Users/ashutosh/Desktop/avalanche-faucet/client/src/components/Metamask.ts":"7","/Users/ashutosh/Desktop/avalanche-faucet/client/src/components/FooterBox.tsx":"8","/Users/ashutosh/Desktop/avalanche-faucet/client/src/components/AddNetwork.tsx":"9"},{"size":177,"mtime":1695802256585,"results":"10","hashOfConfig":"11"},{"size":328,"mtime":1695802256583,"results":"12","hashOfConfig":"11"},{"size":651,"mtime":1695809243791,"results":"13","hashOfConfig":"11"},{"size":19037,"mtime":1695809144984,"results":"14","hashOfConfig":"11"},{"size":615,"mtime":1695802256583,"results":"15","hashOfConfig":"11"},{"size":2536,"mtime":1695802256584,"results":"16","hashOfConfig":"11"},{"size":2575,"mtime":1695809198264,"results":"17","hashOfConfig":"11"},{"size":2195,"mtime":1695802256583,"results":"18","hashOfConfig":"11"},{"size":848,"mtime":1706684872791,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","suppressedMessages":"22","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"ivbwqd",{"filePath":"23","messages":"24","suppressedMessages":"25","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"26","messages":"27","suppressedMessages":"28","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29"},{"filePath":"30","messages":"31","suppressedMessages":"32","errorCount":0,"fatalErrorCount":0,"warningCount":19,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33"},{"filePath":"34","messages":"35","suppressedMessages":"36","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","suppressedMessages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40"},{"filePath":"41","messages":"42","suppressedMessages":"43","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"44"},{"filePath":"45","messages":"46","suppressedMessages":"47","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"48","messages":"49","suppressedMessages":"50","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/ashutosh/Desktop/avalanche-faucet/client/src/index.tsx",[],[],"/Users/ashutosh/Desktop/avalanche-faucet/client/src/App.tsx",[],[],"/Users/ashutosh/Desktop/avalanche-faucet/client/src/configure.ts",["51"],[],"import axios from 'axios'\nimport configurations from './config.json'\n\nexport default axios.create({\n    baseURL: process.env.NODE_ENV == \"production\" ? configurations.apiBaseEndpointProduction : configurations.apiBaseEndpointDevelopment,\n    timeout: configurations.apiTimeout,\n})\n\nexport const config = {\n    api: {\n        sendToken: '/sendToken',\n        getChainConfigs: '/getChainConfigs',\n        getBalance: '/getBalance',\n        faucetAddress: 'faucetAddress'\n    },\n    SITE_KEY: configurations.CAPTCHA.siteKey,\n    V2_SITE_KEY: configurations.CAPTCHA.v2siteKey,\n    ACTION: configurations.CAPTCHA.action,\n    banner: configurations.banner\n}","/Users/ashutosh/Desktop/avalanche-faucet/client/src/components/FaucetForm.tsx",["52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70"],[],"import { useState, useEffect } from 'react'\nimport { ethers } from 'ethers'\nimport { ClipLoader } from \"react-spinners\"\nimport Select from 'react-select'\n\nimport './styles/FaucetForm.css'\nimport ReCaptcha from './ReCaptcha'\nimport FooterBox from './FooterBox'\nimport queryString from 'query-string'\nimport { DropdownOption } from './types'\nimport { connectAccount } from './Metamask'\nimport { AxiosResponse } from 'axios'\n\nconst FaucetForm = (props: any) => {\n    const [chain, setChain] = useState<number | null>(null)\n    const [token, setToken] = useState<number | null>(null)\n    const [widgetID, setwidgetID] = useState(new Map())\n    const [recaptcha, setRecaptcha] = useState<ReCaptcha | undefined>(undefined)\n    const [isV2, setIsV2] = useState<boolean>(false)\n    const [chainConfigs, setChainConfigs] = useState<any>([])\n    const [inputAddress, setInputAddress] = useState<string>(\"\")\n    const [address, setAddress] = useState<string | null>(null)\n    const [faucetAddress, setFaucetAddress] = useState<string | null>(null)\n    const [options, setOptions] = useState<DropdownOption[]>([])\n    const [tokenOptions, setTokenOptions] = useState<DropdownOption[]>([]);\n    const [balance, setBalance] = useState<string>(\"0\")\n    const [shouldAllowSend, setShouldAllowSend] = useState<boolean>(false)\n    const [isLoading, setIsLoading] = useState<boolean>(false)\n    const [isFetchingBalance, setIsFetchingBalance] = useState<AbortController | null>(null)\n    const [sendTokenResponse, setSendTokenResponse] = useState<any>({\n        txHash: null,\n        message: null\n    })\n\n    // Update chain configs\n    useEffect(() => {\n        setRecaptcha(new ReCaptcha(\n            props.config.SITE_KEY,\n            props.config.ACTION,\n            props.config.V2_SITE_KEY,\n            setwidgetID\n        ))\n        updateChainConfigs()\n        connectAccount(updateAddress, false)\n\n    }, [])\n\n    // Update balance whenver chain changes or after transaction is processed\n    useEffect(() => {\n        updateBalance()\n    }, [chain, token, sendTokenResponse, chainConfigs])\n\n    // Make REQUEST button disabled if either address is not valid or balance is low\n    useEffect(() => {\n        if(address) {\n            if(BigInt(balance) > calculateBaseUnit(chainConfigs[token!]?.DRIP_AMOUNT, chainConfigs[token!]?.DECIMALS)) {\n                setShouldAllowSend(true)\n                return\n            }\n        }\n        \n        setShouldAllowSend(false)\n    }, [address, balance])\n\n    useEffect(() => {\n        updateFaucetAddress()\n    }, [chain, chainConfigs])\n\n    useEffect(() => {\n        let newOptions: DropdownOption[] = []\n        \n        chainConfigs?.forEach((chain: any, i: number) => {\n            let item = <div className='select-dropdown'>\n                <img alt = { chain.NAME[0] } src = { chain.IMAGE } />\n                { chain.NAME }\n\n                {\n                    chain.CONTRACTADDRESS &&\n                    <span style={{color: 'rgb(180, 180, 183)', fontSize: \"10px\", marginLeft: \"5px\"}}>\n                        {\n                            chainConfigs[chainToIndex(chain.HOSTID) || 0]?.NAME\n                        }\n                    </span>\n                }\n            </div>\n\n            if(!chain.CONTRACTADDRESS) {\n                newOptions.push({\n                    label: item,\n                    value: i,\n                    search: chain.NAME\n                })\n            }\n        })\n        \n        setOptions(newOptions)\n        setChain(newOptions[0]?.value)\n    }, [chainConfigs])\n\n    useEffect(() => {\n        let newOptions: DropdownOption[] = []\n        \n        chainConfigs?.forEach((chain: any, i: number) => {\n            const { chain: ch } = getChainParams();\n\n            let item = <div className='select-dropdown'>\n                <img alt = { chain.NAME[0] } src = { chain.IMAGE } />\n                { chain.ID == ch ? chain.TOKEN : chain.NAME }\n\n                <span style={{color: 'rgb(180, 180, 183)', fontSize: \"10px\", marginLeft: \"5px\"}}>\n                    {\n                        chain.CONTRACTADDRESS ?\n                        \"ERC20\" :\n                        \"Native\"\n                    }\n                </span>\n            </div>\n\n            if((chain.CONTRACTADDRESS && chain.HOSTID == ch) || chain.ID == ch) {\n                newOptions.push({\n                    label: item,\n                    value: i,\n                    search: chain.NAME\n                })\n            }\n        })\n\n        setTokenOptions(newOptions)\n        setToken(newOptions[0]?.value)\n    }, [chainConfigs, chain])\n\n    const getConfigByTokenAndNetwork = (token: any, network: any): number => {\n        let selectedConfig = 0;\n\n        try {\n            token = token?.toUpperCase();\n            network = network?.toUpperCase();\n            \n            chainConfigs.forEach((chain: any, i: number): any => {\n                if(chain.TOKEN == token && chain.HOSTID == network) {\n                    selectedConfig = i;\n                }\n            })\n        } catch(err: any) {\n            console.log(err)\n        }\n\n        return selectedConfig;\n    }\n\n    let totalTokens: boolean = tokenOptions?.length === 0;\n\n    useEffect(() => {\n        const query = queryString.parse(window.location.search)\n        \n        const { address, subnet, erc20 } = query\n\n        const tokenIndex: number = getConfigByTokenAndNetwork(erc20, subnet)\n        \n        if(typeof address == \"string\") {\n            updateAddress(address)\n        }\n\n        if(typeof subnet == \"string\") {\n            setChain(chainToIndex(subnet))\n            if(typeof erc20 == \"string\") {\n                setToken(tokenIndex)\n            }\n        } else {\n            setChain(0)\n        }\n    }, [window.location.search, options, totalTokens])\n\n    // API calls\n    async function updateChainConfigs(): Promise<void> {\n        const response: AxiosResponse = await props.axios.get(\n            props.config.api.getChainConfigs\n        )\n        setChainConfigs(response?.data?.configs)\n    }\n\n    function getChainParams(): {chain: string, erc20: string} {\n        let params = {\n            chain: chainConfigs[chain!]?.ID,\n            erc20: chainConfigs[token!]?.ID\n        }\n\n        return params\n    }\n\n    async function updateBalance(): Promise<void> {\n        // Abort pending requests\n        const controller = new AbortController();\n        if(isFetchingBalance) {\n            isFetchingBalance.abort()\n        }\n        setIsFetchingBalance(controller)\n\n        if((chain || chain == 0) && chainConfigs.length > 0) {\n            let { chain, erc20 } = getChainParams()\n            \n            const response: AxiosResponse = await props.axios.get(props.config.api.getBalance, {\n                params: {\n                    chain,\n                    erc20\n                },\n                signal: controller.signal\n            })\n        \n            if(response?.data?.balance || response?.data?.balance == 0) {\n                setBalance(response?.data?.balance)\n            }\n        }\n    }\n\n    async function updateFaucetAddress(): Promise<void> {\n        if((chain || chain == 0) && chainConfigs.length > 0) {\n            let { chain } = getChainParams()\n            \n            const response: AxiosResponse = await props.axios.get(props.config.api.faucetAddress, {\n                params: {\n                    chain\n                }\n            })\n            \n            if(response?.data) {\n                setFaucetAddress(response?.data?.address)\n            }\n        }\n    }\n\n    function calculateBaseUnit(amount: string = \"0\", decimals: number = 18): BigInt {\n        for(let i = 0; i < decimals; i++) {\n            amount += \"0\"\n        }\n        return BigInt(amount)\n    }\n\n    function calculateLargestUnit(amount: string = \"0\", decimals: number = 18): string {\n        let base = \"1\"\n        for(let i = 0; i < decimals; i++) {\n            base += \"0\"\n        }\n        return (BigInt(amount) / BigInt(base)).toString()\n    }\n\n    function chainToIndex(id: any): number | null {\n        if(chainConfigs?.length > 0) {\n            if(typeof id == \"string\") {\n                id = id.toUpperCase()\n            }\n            let index: number = 0\n            chainConfigs.forEach((chain: any, i: number) => {\n                if(id == chain.ID) {\n                    index = i\n                }\n            })\n            return index\n        } else {\n            return null\n        }\n    }\n\n    function updateAddress(addr: any): void {\n        setInputAddress(addr!)\n        \n        if (addr) {\n            if (ethers.utils.isAddress(addr)) {\n                setAddress(addr)\n            } else {\n                setAddress(null)\n            }\n        } else if (address != null) {\n            setAddress(null)\n        }\n    }\n\n    async function getCaptchaToken(index: number = 0): Promise<{token?:string, v2Token?: string}> {\n        const { token, v2Token } = await recaptcha!.getToken(isV2, widgetID, index)\n        return { token, v2Token }\n    }\n\n    function updateChain(option: any): void {\n        let chainNum: number = option.value\n        \n        if(chainNum >= 0 &&  chainNum < chainConfigs.length) {\n            setChain(chainNum)\n            back()\n        }\n    }\n\n    function updateToken(option: any): void {\n        let tokenNum: number = option.value\n        \n        if(tokenNum >= 0 &&  tokenNum < chainConfigs.length) {\n            setToken(tokenNum)\n            back()\n        }\n    }\n\n    const ifCaptchaFailed = (data: any, index: number = 0, reload: boolean = false) => {\n        if(typeof data?.message == \"string\") {\n            if(data.message.includes(\"Captcha verification failed\")) {\n                setIsV2(true)\n                recaptcha?.loadV2Captcha(props.config.V2_SITE_KEY, widgetID, index, reload);\n            }\n        }\n    }\n\n    async function sendToken(): Promise<void> {\n        if(!shouldAllowSend) {\n            return\n        } \n        let data: any\n        try {\n            setIsLoading(true)\n\n            const { token, v2Token } = await getCaptchaToken()\n\n            let { chain, erc20 } = getChainParams()\n\n            const response = await props.axios.post(props.config.api.sendToken, {\n                address,\n                token,\n                v2Token,\n                chain,\n                erc20\n            })\n            data = response?.data\n        } catch(err: any) {\n            data = err?.response?.data || err\n        }\n\n        ifCaptchaFailed(data)\n\n        setSendTokenResponse({\n            txHash: data?.txHash,\n            message: data?.message\n        })\n\n        setIsLoading(false)\n    }\n\n    const getOptionByValue = (value: any): DropdownOption => {\n        let selectedOption: DropdownOption = options[0]\n        options.forEach((option: DropdownOption): void => {\n            if(option.value == value) {\n                selectedOption = option\n            }\n        })\n        return selectedOption\n    }\n\n    const getTokenOptionByValue = (value: any): DropdownOption => {\n        let selectedOption: DropdownOption = tokenOptions[0]\n        tokenOptions.forEach((option: DropdownOption): void => {\n            if(option.value == value) {\n                selectedOption = option\n            }\n        })\n        return selectedOption\n    }\n\n    const customStyles = {\n        control: (base: any, state: { isFocused: any }) => ({\n            ...base,\n            background: \"#333\",\n            borderRadius: state.isFocused ? \"5px 5px 0 0\" : 5,\n            borderColor: state.isFocused ? \"white\" : \"#333\",\n            boxShadow: null,\n            \"&:hover\": {\n                borderColor: \"white\"\n            }\n        }),\n        menu: (base: any) => ({\n            ...base,\n            borderRadius: 0,\n            marginTop: 0,\n            background: \"rgb(45, 45, 45)\",\n            color: \"white\"\n        }),\n        menuList: (base: any) => ({\n            ...base,\n            padding: 0,\n            \"::-webkit-scrollbar\": {\n                width: \"2px\"\n            },\n            \"::-webkit-scrollbar-track\": {\n                background: \"black\"\n            },\n            \"::-webkit-scrollbar-thumb\": {\n                background: \"#888\"\n            },\n            \"::-webkit-scrollbar-thumb:hover\": {\n                background: \"#555\"\n            }\n        }),\n        option: (styles: any, {isFocused, isSelected}: any) => ({\n            ...styles,\n            background: isFocused\n                    ?\n                    'black'\n                    :\n                    isSelected\n                    ?\n                    '#333'\n                    :\n                    undefined,\n            zIndex: 1\n        }),\n        input: (base: any) => ({\n            ...base,\n            color: \"white\"\n        }),\n        singleValue: (base: any) => ({\n            ...base,\n            color: \"white\"\n        })\n    }\n\n    const ChainDropdown = () => (\n        <div style={{width: \"100%\", marginTop: \"5px\"}}>\n            <Select\n                options={options}\n                value={getOptionByValue(chain)}\n                onChange={updateChain}\n                styles={customStyles}\n                getOptionValue ={(option: any)=>option.search}\n            />\n        </div>\n    )\n\n    const TokenDropdown = () => (\n        <div style={{width: \"100%\"}}>\n            <Select\n                options={tokenOptions}\n                value={getTokenOptionByValue(token)}\n                onChange={updateToken}\n                styles={customStyles}\n                getOptionValue ={(option: any)=>option.search}\n            />\n        </div>\n    )\n\n    const resetRecaptcha = (): void => {\n        setIsV2(false)\n        recaptcha!.resetV2Captcha(widgetID)\n    }\n\n    const back = (): void => {\n        resetRecaptcha()\n        setSendTokenResponse({\n            txHash: null,\n            message: null\n        })\n    }\n\n    const toString = (mins: number): string => {\n        if(mins < 60) {\n            return `${mins} minute${mins > 1 ? 's' : ''}`\n        } else {\n            const hour = ~~(mins / 60)\n            const minute = mins % 60\n\n            if(minute == 0) {\n                return `${hour} hour${hour > 1 ? 's' : ''}`\n            } else {\n                return `${hour} hour${hour > 1 ? 's' : ''} and ${minute} minute${minute > 1 ? 's' : ''}`\n            }\n        }\n    }\n\n    return (\n        <div className='container'>\n            <div className = \"box\">\n                <div className='banner' style={{backgroundImage: `url(${props.config.banner})`}}/>\n\n                <div className='box-content'>\n                    <div className='box-header'>\n                        <span>\n                            <span style={{color: \"grey\"}}>Select Network</span>\n                        </span>\n\n                        <ChainDropdown /> <br/>\n\n                        <div>\n                            <div style={{width: \"100%\"}}>\n                                <span style={{color: \"grey\", fontSize: \"12px\", float: \"right\"}}>\n                                    Faucet balance: {calculateLargestUnit(balance, chainConfigs[token!]?.DECIMALS)} {chainConfigs[token!]?.TOKEN}\n                                </span>\n\n                                <span style={{color: \"grey\", fontSize: \"12px\"}}>\n                                    Select Token\n                                </span>\n\n                                <TokenDropdown/>\n                            </div>\n                        </div>\n                    </div>\n\n                    <br/>\n\n                    <div style={{ display: sendTokenResponse?.txHash ? \"none\" : \"block\" }}>\n                        <p className='rate-limit-text'>\n                            Drops are limited to \n                            <span>\n                                {chainConfigs[token!]?.RATELIMIT?.MAX_LIMIT} request in {toString(chainConfigs[token!]?.RATELIMIT?.WINDOW_SIZE)}.\n                            </span>\n                        </p>\n\n                        <div className='address-input'>\n                            <input\n                                placeholder='Hexadecimal Address (0x...)'\n                                value={inputAddress || \"\"}\n                                onChange={(e) => updateAddress(e.target.value)}\n                                autoFocus\n                            />\n\n                            <span className='connect-metamask' onClick={ () => connectAccount(updateAddress) }>\n                                <img alt='metamask' src=\"/memtamask.webp\"/>\n                                Connect\n                            </span>\n                        </div>\n                        <span className='rate-limit-text' style={{color: \"red\"}}>{sendTokenResponse?.message}</span>\n\n                        <div className='v2-recaptcha' style={{marginTop: \"10px\"}}></div>\n                        \n                        <div className=\"beta-alert\">\n                            <p>This is a testnet faucet. Funds are not real.</p>\n                        </div>\n                    \n                        <button className={shouldAllowSend ? 'send-button' : 'send-button-disabled'} onClick={sendToken}>\n                            {\n                                isLoading\n                                ?\n                                <ClipLoader size=\"20px\" speedMultiplier={0.3} color=\"403F40\"/>\n                                :\n                                <span>Request {chainConfigs[token || 0]?.DRIP_AMOUNT} {chainConfigs[token || 0]?.TOKEN}</span>\n                            }\n                        </button>\n                    </div>\n                    \n                    <div style={{ display: sendTokenResponse?.txHash ? \"block\" : \"none\" }}>\n                        <p className='rate-limit-text'>\n                            {sendTokenResponse?.message}\n                        </p>\n\n                        <div>\n                            <span className='bold-text'>Transaction ID</span>\n                            <p className='rate-limit-text'>\n                                <a\n                                    target = {'_blank'}\n                                    href = {chainConfigs[token!]?.EXPLORER + '/tx/' + sendTokenResponse?.txHash}\n                                    rel = \"noreferrer\"\n                                >\n                                    {sendTokenResponse?.txHash}\n                                </a>\n                            </p>\n                        </div>\n\n                        <button className='back-button' onClick={back}>Back</button>\n                    </div>\n                </div>\n            </div>\n\n            <FooterBox\n                chain = {chain}\n                token = {token}\n                chainConfigs = {chainConfigs}\n                chainToIndex = {chainToIndex}\n                faucetAddress = {faucetAddress}\n            />\n        </div>\n\n\n    )\n}\n\nexport default FaucetForm","/Users/ashutosh/Desktop/avalanche-faucet/client/src/components/Contribute.tsx",[],[],"/Users/ashutosh/Desktop/avalanche-faucet/client/src/components/ReCaptcha.ts",["71","72"],[],"declare global {\n    interface Window {\n        grecaptcha: any\n    }\n}\n\nexport default class ReCaptcha {\n    siteKey: string\n    v2siteKey?: string\n    action: string\n    setWidgetID: any\n        \n    constructor(SITE_KEY: string, ACTION: string, V2_SITE_KEY: string, setWidgetID: any) {\n        this.loadReCaptcha(SITE_KEY)\n        \n        this.siteKey = SITE_KEY\n        this.v2siteKey = V2_SITE_KEY\n        this.action = ACTION\n        this.setWidgetID = setWidgetID\n    }\n\n    async getToken(isV2 = false, widgetID: any, index: number = 0): Promise<{token?: string, v2Token?: string}> {\n        let token = \"\", v2Token = \"\"\n        !isV2 && await window.grecaptcha.execute(this.siteKey, {action: this.action})\n            .then((res: string) => {\n                token = res\n            })\n        \n        if(isV2){\n            v2Token = await window.grecaptcha.getResponse(widgetID.get(index))\n        }\n\n        return { token, v2Token }\n    }\n\n    resetV2Captcha = (widgetID: any, index: number = 0) => {\n        const v2CaptchaContainer = document.getElementsByClassName('v2-recaptcha')[index] as HTMLElement\n        if(v2CaptchaContainer) {\n            if(widgetID.get(index) || widgetID.get(index) == 0) {\n                window.grecaptcha.reset(widgetID.get(index))\n            }\n            v2CaptchaContainer.style.display = \"none\"\n        }\n    }\n\n    loadV2Captcha = (v2siteKey: string, widgetID: any, index: number = 0, reload: boolean = false) => {\n        this.resetV2Captcha(widgetID, index)\n        const v2CaptchaContainer = document.getElementsByClassName('v2-recaptcha')[index] as HTMLElement\n        if((widgetID.get(index) || widgetID.get(index) == \"0\") && !reload) {\n            const v2CaptchaContainer = document.getElementsByClassName('v2-recaptcha')[index] as HTMLElement\n            if(v2CaptchaContainer) {\n                v2CaptchaContainer.style.display = \"block\"\n            }\n        } else {\n            v2CaptchaContainer.style.display = \"block\"\n            const newWidgetID = window.grecaptcha.render(v2CaptchaContainer, {\n                'sitekey' : v2siteKey,\n                'theme': 'dark'\n            })\n            widgetID.set(index, newWidgetID)\n            this.setWidgetID(widgetID)\n        }\n\n        return true\n    }\n\n    loadReCaptcha = (siteKey: string): boolean => {\n        const script = document.createElement('script')\n        script.src = `https://www.recaptcha.net/recaptcha/api.js?render=${siteKey}`\n\n        document.body.appendChild(script)\n        return true\n    }\n}","/Users/ashutosh/Desktop/avalanche-faucet/client/src/components/Metamask.ts",["73","74","75"],[],"declare global {\n    interface Window {\n        ethereum: any\n    }\n}\n\nexport const addNetwork = async (config: any): Promise<void> => {\n    if(!config) {\n        return\n    }\n    if(window.ethereum == undefined) {\n        window.open('https://metamask.io/download', '_blank')\n    }\n\n    await window?.ethereum?.request({\n        method: 'wallet_addEthereumChain',\n        params: [{\n            chainId: `0x${config.CHAINID?.toString(16)}`,\n            chainName: config.NAME,\n            nativeCurrency: {\n                name: config.NAME,\n                symbol: config.TOKEN,\n                decimals: 18\n            },\n            rpcUrls: [config.RPC],\n            blockExplorerUrls: config.EXPLORER ? [config.EXPLORER] : null\n        }]\n    }).catch((error: any): void => {\n        console.log(error)\n    })      \n}\n\nexport const addAsset = async (config: any): Promise<void> => {\n    if(!config) {\n        return\n    }\n    if(window.ethereum == undefined) {\n        window.open('https://metamask.io/download', '_blank')\n    }\n\n    await window?.ethereum?.request({\n        method: 'wallet_watchAsset',\n        params: {\n            type: 'ERC20',\n            options: {\n                address: config.CONTRACTADDRESS,\n                symbol: config.TOKEN,\n                decimals: config.DECIMALS || 18\n            }\n        }\n    }).catch((error: any): void => {\n        console.log(error)\n    })  \n}\n\nexport const connectAccount = async (updateAddress: any, showPopup = true) => {\n    if(window.ethereum == undefined) {\n        showPopup && window.open('https://metamask.io/download', '_blank')\n        return\n    }\n\n    try {\n        window.ethereum.request({ method: 'eth_accounts' }).then(\n            async (accounts: any) => {\n                accounts = await handleConnection(accounts, showPopup)\n                updateAddress(accounts[0])\n            }\n        ).catch(\n            console.error\n        )\n\n        window.ethereum.on('accountsChanged', async function () {\n            const accounts = await window.ethereum.enable()\n            updateAddress(accounts[0]);\n        })\n    } catch {\n        alert(\"Request denied!\")\n    }\n}\n\nasync function handleConnection(accounts: any, showPopup: boolean) {\n    if(accounts.length === 0) {\n        if(showPopup) {\n            try {\n                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' })\n                return accounts\n            } catch(err) {\n                console.log(\"Request denied!\")\n            }\n        }\n    } else {\n        return accounts\n    }\n}","/Users/ashutosh/Desktop/avalanche-faucet/client/src/components/FooterBox.tsx",[],[],"/Users/ashutosh/Desktop/avalanche-faucet/client/src/components/AddNetwork.tsx",[],[],{"ruleId":"76","severity":1,"message":"77","line":5,"column":35,"nodeType":"78","messageId":"79","endLine":5,"endColumn":37},{"ruleId":"80","severity":1,"message":"81","line":46,"column":8,"nodeType":"82","endLine":46,"endColumn":10,"suggestions":"83"},{"ruleId":"80","severity":1,"message":"84","line":51,"column":8,"nodeType":"82","endLine":51,"endColumn":55,"suggestions":"85"},{"ruleId":"80","severity":1,"message":"86","line":63,"column":8,"nodeType":"82","endLine":63,"endColumn":26,"suggestions":"87"},{"ruleId":"80","severity":1,"message":"88","line":67,"column":8,"nodeType":"82","endLine":67,"endColumn":29,"suggestions":"89"},{"ruleId":"80","severity":1,"message":"90","line":98,"column":8,"nodeType":"82","endLine":98,"endColumn":22,"suggestions":"91"},{"ruleId":"76","severity":1,"message":"77","line":108,"column":28,"nodeType":"78","messageId":"79","endLine":108,"endColumn":30},{"ruleId":"76","severity":1,"message":"77","line":119,"column":55,"nodeType":"78","messageId":"79","endLine":119,"endColumn":57},{"ruleId":"76","severity":1,"message":"77","line":119,"column":74,"nodeType":"78","messageId":"79","endLine":119,"endColumn":76},{"ruleId":"80","severity":1,"message":"92","line":130,"column":8,"nodeType":"82","endLine":130,"endColumn":29,"suggestions":"93"},{"ruleId":"76","severity":1,"message":"77","line":140,"column":32,"nodeType":"78","messageId":"79","endLine":140,"endColumn":34},{"ruleId":"76","severity":1,"message":"77","line":140,"column":57,"nodeType":"78","messageId":"79","endLine":140,"endColumn":59},{"ruleId":"80","severity":1,"message":"94","line":172,"column":8,"nodeType":"82","endLine":172,"endColumn":54,"suggestions":"95"},{"ruleId":"76","severity":1,"message":"77","line":199,"column":28,"nodeType":"78","messageId":"79","endLine":199,"endColumn":30},{"ruleId":"76","severity":1,"message":"77","line":210,"column":67,"nodeType":"78","messageId":"79","endLine":210,"endColumn":69},{"ruleId":"76","severity":1,"message":"77","line":217,"column":28,"nodeType":"78","messageId":"79","endLine":217,"endColumn":30},{"ruleId":"76","severity":1,"message":"77","line":254,"column":23,"nodeType":"78","messageId":"79","endLine":254,"endColumn":25},{"ruleId":"76","severity":1,"message":"77","line":347,"column":29,"nodeType":"78","messageId":"79","endLine":347,"endColumn":31},{"ruleId":"76","severity":1,"message":"77","line":357,"column":29,"nodeType":"78","messageId":"79","endLine":357,"endColumn":31},{"ruleId":"76","severity":1,"message":"77","line":465,"column":23,"nodeType":"78","messageId":"79","endLine":465,"endColumn":25},{"ruleId":"76","severity":1,"message":"77","line":39,"column":59,"nodeType":"78","messageId":"79","endLine":39,"endColumn":61},{"ruleId":"76","severity":1,"message":"77","line":49,"column":56,"nodeType":"78","messageId":"79","endLine":49,"endColumn":58},{"ruleId":"76","severity":1,"message":"77","line":11,"column":24,"nodeType":"78","messageId":"79","endLine":11,"endColumn":26},{"ruleId":"76","severity":1,"message":"77","line":37,"column":24,"nodeType":"78","messageId":"79","endLine":37,"endColumn":26},{"ruleId":"76","severity":1,"message":"77","line":57,"column":24,"nodeType":"78","messageId":"79","endLine":57,"endColumn":26},"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'props.config.ACTION', 'props.config.SITE_KEY', 'props.config.V2_SITE_KEY', 'updateAddress', and 'updateChainConfigs'. Either include them or remove the dependency array. If 'setRecaptcha' needs the current value of 'props.config.SITE_KEY', you can also switch to useReducer instead of useState and read 'props.config.SITE_KEY' in the reducer.","ArrayExpression",["96"],"React Hook useEffect has a missing dependency: 'updateBalance'. Either include it or remove the dependency array.",["97"],"React Hook useEffect has missing dependencies: 'chainConfigs' and 'token'. Either include them or remove the dependency array.",["98"],"React Hook useEffect has a missing dependency: 'updateFaucetAddress'. Either include it or remove the dependency array.",["99"],"React Hook useEffect has a missing dependency: 'chainToIndex'. Either include it or remove the dependency array.",["100"],"React Hook useEffect has a missing dependency: 'getChainParams'. Either include it or remove the dependency array.",["101"],"React Hook useEffect has missing dependencies: 'chainToIndex', 'getConfigByTokenAndNetwork', and 'updateAddress'. Either include them or remove the dependency array. Outer scope values like 'window.location.search' aren't valid dependencies because mutating them doesn't re-render the component.",["102"],{"desc":"103","fix":"104"},{"desc":"105","fix":"106"},{"desc":"107","fix":"108"},{"desc":"109","fix":"110"},{"desc":"111","fix":"112"},{"desc":"113","fix":"114"},{"desc":"115","fix":"116"},"Update the dependencies array to be: [props.config.ACTION, props.config.SITE_KEY, props.config.V2_SITE_KEY, updateAddress, updateChainConfigs]",{"range":"117","text":"118"},"Update the dependencies array to be: [chain, token, sendTokenResponse, chainConfigs, updateBalance]",{"range":"119","text":"120"},"Update the dependencies array to be: [address, balance, chainConfigs, token]",{"range":"121","text":"122"},"Update the dependencies array to be: [chain, chainConfigs, updateFaucetAddress]",{"range":"123","text":"124"},"Update the dependencies array to be: [chainConfigs, chainToIndex]",{"range":"125","text":"126"},"Update the dependencies array to be: [chainConfigs, chain, getChainParams]",{"range":"127","text":"128"},"Update the dependencies array to be: [options, totalTokens, getConfigByTokenAndNetwork, updateAddress, chainToIndex]",{"range":"129","text":"130"},[1896,1898],"[props.config.ACTION, props.config.SITE_KEY, props.config.V2_SITE_KEY, updateAddress, updateChainConfigs]",[2032,2079],"[chain, token, sendTokenResponse, chainConfigs, updateBalance]",[2470,2488],"[address, balance, chainConfigs, token]",[2550,2571],"[chain, chainConfigs, updateFaucetAddress]",[3539,3553],"[chainConfigs, chainToIndex]",[4581,4602],"[chainConfigs, chain, getChainParams]",[5761,5807],"[options, totalTokens, getConfigByTokenAndNetwork, updateAddress, chainToIndex]"]